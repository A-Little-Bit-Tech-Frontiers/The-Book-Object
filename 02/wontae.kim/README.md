# 2장 객체지향 프로그래밍

객체지향 프로그래밍의 핵심적인 요소를 맛보여 주면서 간단히 소개한다. 설계원칙, 특히 **다형성**에 대해 자세히 설명했다. 유연한 확장을 위해 다형성을 사용하는 다양한 이유를 보여주고, 장단점에 따른 트레이드오프도 설명한다.

- **객체지향으로 설계할 때 중요한 점**
    1. 클래스를 설계하기 전에 어떤 객체들이 필요한지 먼저 고민하라.
        1. 클래스는 공통적인 상태와 행동을 공유하는 객체를 추상화한 것에 불과하다.
        2. 객체 중심의 접근 방법은 설계를 단순하고 깔끔하게 만든다.
    2. 객체를 독립적인 존재가 아닌 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.
- **도메인(Domain)**
    
    문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 일컬음
    
- **객체지향이 강력한 이유**
    
    요구사항 분석 단계부터 프로그램이 완전히 개발될 때 까지 객체라는 방법으로 동일한 추상화가 가능하기 때문
    

객체는 상태와 행동을 동시에 가지는 복합적인 존재이며 자율적으로 판단하는 존재이다.

객체는 접근 제한자를 통해 인터페이스와 구현부로 분리할 수 있으며 이는 객체지향에서 필수적으로 따라야 하는 원칙이다.

캡슐화를 통해 객체를 묶고 접근 제한자를 통해 클라이언트측에서 사용가능한 공개 인터페이스를 노출함으로써 내부 구현에 대한 변경을 유용하게 할 수 있다. 이것을 정보 은닉 이라고 한다.

### 불변성을 위한 메서드 설계

‘협력하는 객체들의 공통성` 섹션에서 Money 클래스를 정의하는 부분에서 관심있게 볼만한 부분이 있는데, **불변성을 고려한 내부 메서드 설계**를 했다는 점이다.

```java
public class Money {
	private final Bigdecimal amount;
	
	public Bigdecimal minus(Bigdecimal target) {
		**// 완전히 새로운 객체를 리턴함으로써 연산에 사용된 객체의 변경에 대해 신경쓰지 않아도 된다.**
		return new Money(this.amount.subtract(target.amount))
	}
}
```

### 다형성을 잘 이용하는 디자인 패턴

GOF 에서 소개한 **템플릿 메서드 패턴**은 추상 메서드의 사용자 메서드에서는 흐름만 먼저 정의해두고, **추상 메서드의 구현은 상속받는 하위 클래스에 위임하는 패턴이다.** 이렇게 하면 사용자 메서드에서는 오버라이딩된 하위 클래스의 메서드를 호출하게 됨으로써 같은 흐름을 여러 하위 클래스에서 재사용할 수 있다.

```java
public abstract class Test {
	public void command() {
		// re-using logic...
		execute();
	}

	abstract protected void execute();
}

public class InheritedTest implements Test { ... }
```

### 컴파일 시간 의존성과 실행 시간 의존성

다형성을 통해 추상 클래스 인터페이스 의존성 관계를 구축하면 의존 관계가 유연해지고 확장성이 올라간다. 반면 단점도 존재하는데 코드 상으로는 직접적인 의존 관계를 찾을 수 없어 분석하기 어려워 질 수 있다는 점이다.

### 상속의 트레이드오프

상속을 사용하면 서브 클래싱을 통해 기존 클래스를 확장할 수 있다. 하지만 재사용을 위해 상속을 하는 것이 오히려 독이 될 수 있다. 상속을 하게 되면 상속된 자손 클래스들에 미치는 사이드 이펙트 등을 고려하게 되어 **설계의 유연성을 약화**시키고, **캡슐화의 원칙을 위반**한다. 상속의 대체재로 합성(Composite)이 그런 단점을 대체하기 위한 방법 중 하나이다.

**합성을 사용한 상속 대체 예시**

```java
// 상속으로 결합된 Movie 클래스
public class VipMovie extends Movie {
	VipDiscountPolicy discountPolicy;
	...
}

**// 합성으로 대체된 Movie 클래스**
public class Movie {
	DiscountPolicy discountPolicy;
	
	// 상속을 사용한다면 Movie 클래스 자체를 확장해야 했지만,
	// 정책을 별도의 인스턴스 변수로 두어 인스턴스만 교체하면 변경되도록 하여 결합성을 제거했다.
	public void changePolicy(DiscountPolicy discountPolicy) {
		this.discountPolicy = discountPolicy;
	}
}
```