# 3장 역할, 책임, 협력

객체지향 관점에서 가장 중요한 것은 역할, 책임, 협력 이며 협력하는 객체들의 공동체를 창조하는 것이 본질이다.

- 협력 - 객체들이 메세지를 주고받으며 상호작용 하는 것
- 책임 - 협력하기 위해 수행하는 동작
- 역할 - 협력하며 수행하는 책임이 모여 역할을 구성

### 협력

객체에서 객체에게 무언가 요청을 맡기는 것을 메시지 전송의 개념으로 볼 수 있다. A 객체에서 무언가 계산을 B 객체에 맡긴다고 하면, `B.calculate(amount)` 와 같이 **메서드 호출**로 사용하게 된다. B 객체는 협력을 위해 자신의 책임을 **캡슐화** 하여 외부로부터 호출될 수 있으며 독립적인 효과를 가지는 책임을 결정하게 된다. 협력은 객체의 존재 의의와 행동을 결정하는 주요한 **문맥**을 제공한다.

### 책임

객체지향 설계에서 가장 핵심적인 요소로써, 협력하기 위해 객체가 수행하는 행동을 가리킨다. 협력에 따라 자신의 책임을 결정하지만, 더 중요한 것은 **책임을 수행하는데 필요한 정보를 가장 잘 알고, 잘 수행하는 객체에 할당하는 것**이다.

책임을 잘 할당하기 위해 **책임 주도 설계**와 같은 방법을 사용할 수 있는데, 이와 같은 방법의 핵심적인 목적은 전체 시스템에서 필요한 책임을 세분화하고, 세분화된 책임을 수행할 수 있는 각 객체에 부여하고 필요한 경우 다른 객체에 또 다른 책임을 할당하고 협력하게 하는 과정을 거쳐 유연한 객체지향 설계를 하기 위함이다.

```
협력 = 참조 => 역할 = 선택 => 객체 = 사용자 => 클래스
```

책임을 설계하기 위해 외부에서 호출할 수 있는 인터페이스를 만들어야 하는데, 이때 행동을 기반으로 인터페이스를 만들어야 한다. `setCompany(String company)` 와 같은 인터페이스는 데이터 의존적이기 때문에 데이터가 변경되면 인터페이스 또한 변경되어야 하기에 데이터 주도 설계라고 하는데, 이와 같은 방법은 행동을 예측하기 어렵고 변경에 취약하다. **책임을 설계하기 위해서는 행동을 우선적으로 결정해야 하고, 데이터는 그것을 위한 상태에 불과하다는 것이 중요하다.**

### 역할

책임의 집합을 가리키며, 객체의 추상화된 상위 인터페이스 정도의 개념으로 볼 수 있다. 예를 들면 `WarriorAttack` 이라는 책임이 있고 `ArchorAttack` 이라는 책임이 있을 때, 이들은 동일한 `Attack` 이라는 공통적인 책임을 가지고 있다. 이러한 공통 분모를 인터페이스로 추상화 했을 때, 이것을 역할로 취급할 수 있다.

```java
interface Attack { ... }

public class WarriorAttack implements Attack {
	@Override
	void action(ActionCommand command) { ... }
}
public class ArchorAttack implements Attack {
	@Override
	void action(ActionCommand command) { ... }
}
```

이와 같이 역할은 책임을 갈아끼울 수 있는 슬롯(인터페이스)으로 비유할 수 있다. 객체는 의미있는 역할을 재정의하는 책임을 통해 앱에서의 기능을 담당하게 된다. 즉, 역할을 정의하면서 설계하게 되면 책임들을 추상화하고 유연한 설계를 할 수 있다.

### 실제로 객체지향을 설계할 때

협력, 역할, 책임, 객체를 모두 또렷하게 분리하기는 쉽지 않다. 그렇기 때문에, 초기에는 큰 그림에서 흔히 사용하는 ‘도메인’ 의 개념으로 접근해서 역할을 기준으로 객체를 분리하고 협력할 때 수행되는 **책임들의 중복성과 응집도가 눈에 보이는 시점에 점진적으로 분리하는 것이 현실적으로 접근하기 좋은 방법**일 것이다. 이 때 중요한 것은 행동 기반으로 역할과 책임을 분리해야 한다.