## 캡슐화
외부에서 알 필요가 없는 부분을 인터페이스 뒤로 감추고, 외부에서는 인터페이스에만 의존하도록 분리하는 것이 핵심이다.

## 응집도
객체 또는 클래슫에 얼마나 관련 높은 책임들을 할당했는지를 나타낸다.

## 결합도
객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하고 있는지를 나타낸다.

## 그렇다면 좋은 설계란?
애플리케이션을 구성하는 각 요소의 응집도가 높고 서로 느슨하게 결합돼있다면 좋은 설계라고 할 수 있다. 

응집도가 높은 설계일수록 **하나의 요구사항을 반영하기 위해 오직 하나의 모듈만 수정이 가능**하다면, 그에 반해 **응집도가 낮다면 하나의 변경에 의해서 다른 모듈들까지 동시에 변경**되어야 하기 때문이다.
즉, 응집도가 높을수록 변경의 대상과 범위가 명확해진다.

결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경이 얼마나 일어나는지 그 정도로 측정 가능하다.
**낮은 결합도를 가진 설계일수록 하나의 모듈만은 변경하면 오직 그 모듈만 영향**을 받게 되지만, **높은 결합도를 가진 설계일수록 하나의 모듈만을 변경하더라도 다른 모듈들까지 동시에 변경**해야 한다.

그리고, 캡슐화의 정도가 응집도와 결합도에 영향을 미칠 수 있다. 캡슐화의 강도가 높을 수록 응집도는 높아지고(내부에서만 구현 사실을 알기 때문이다), 결합도는 낮아진다(외부에서는 역할이란 책임의 추상적인 존재만을 알기 때문이다).


## 예시

내부의 상태에 무게중심을 둬서 캡슐화를 위반한 경우와 외부에 무게중심을 맞추서 설계했을 때, 어떤 차이가 있는지 살펴보자.

만약, 어떤 고객이 소유하고 있는 계좌가 있다고 가정하자. 
이 계좌는 A인증이 완료되어야 사용이 가능한 것이다.

내부의 상태를 무게중심으로 둬서 설계를 한다면 아래와 같은 문제가 발생 가능하다.

```java
class Wallet {
  ...
  private final STATE state;

  public Boolean isStateA() {
    return this.state == STATE.A;
  }
}
```
위와 같이 내부에 A라는 상태에 무게중심을 둬서 메서드명을 isStateA()라고 지었다. 메서드명을 이렇게 지은것부터가 사실 캡슐화를 위반하고, 응집도가 낮아지며 또한 결합도가 높아진 예시라고 할 수 있다.
그 이유는 외부에서는 벌써부터 계좌의 사용조건이 A상태여야한다는 사실을 알고 있는 것이고, 만약 사용가능 조건이 B로 변경된다면 무슨일이 무슨 Wallet 뿐만 아니라 isStateA()를 사용하는 여러 모듈들도 다 변경되어야 한다.

그럼, 어떻게 캡슐화를 할 수 있을까?
핵심은 행동이 무엇인지를 먼저 생각하면 된다. 즉, 메시지를 먼저 생각하고 퍼블릭 인터페이스를 설계하는 방식인 것이다. (3장)

```java
class Wallet {
  ...
  private final STATE state;

  public Boolean isAvailable() {
    return this.state == STATE.A;
  }
}
```

메서드명만 변경하였다. `isStateA() -> isAvailable()`로.
그렇다면, 다른 모듈에서 이 지갑이 사용 가능한지 확인하고 싶다면 그냥 isAvailable()만을 호출하면 되는 것이고, 사용가능 조건이 B로 변경된다고 하더라도 해당 메서드 내부 구현만 변경하면 된다.
이런식의 캡슐화가 각 모듈간 응집도를 높이고(Wallet 모듈의 응집도), 결합도를 낮추는(Wallet과 다른 모듈들) 효과를 가져올 수 있다. 당연히 이는 변경에 용이한 설계로 이어질 것이다.
