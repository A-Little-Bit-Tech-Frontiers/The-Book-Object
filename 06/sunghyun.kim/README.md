# 협력과 메시지

### 클라이언트 - 서버 모델

협력은 어떤 객체가 다른 객체에게 무언가를 요청할 때 시작된다. <br>
협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체는 서버라고 부른다. <br>
협력은 클라이언트 -> 서버로 요청하는 단방향 상호작용이다.

### 메시지와 메시지 전송

메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다. <br>
메시지는 오퍼레이션명과 인자로 구성되며, 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

### 퍼블릭 인터페이스와 오퍼레이션

객체는 안과 밖을 구분하는 뚜렷한 경계를 가지고, 외부의 객체는 오직 객체가 공개하는 메시지를 통해서만 객체와 상호작용할 수 있다. <br>
객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 퍼블릭 인터페이스라고 부른다. <br>
퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 부르고, 오퍼레이션은 수행 가능한 행동에 대한 추상화이다.

<br>
<hr>

# 인터페이스와 설계 품질

좋은 인터페이스는 최소한의 인터페이스와 추상적인 인터페이스라는 조건을 만족해야 한다. <br>
이를 설계하는 가장 좋은 방법은 아래의 원칙을 지키는 것이다.

### 디미터 법칙

협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 문제를 해결하기 위해 제안된 원칙이 디미터 법칙이다. <br>
이는 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. <br>

쉽게 말하면, 클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송해야 한다.

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체


### 묻지 말고 시켜라

메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후, 메시지 수신자의 상태를 바꿔서는 안된다. <br>
객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한 것이다. <br>
상태를 묻는 오퍼레이션을 행동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜야 한다.

### 의도를 드러내는 인터페이스

```java
// AS-IS
public class PeriodCondition {
    public boolean isSatisfiedByPeriod(Screening screening) {}
}

public class SequenceCondition {
    public boolean isSatisfiedBySequence(Screening screening) {}
}
```

위 스타일은 아래와 같은 이유로 좋지 않다.

- 클라이언트 관점에서 isSatisfiedByPeriod와 isSatisfiedBySequence 모두 할인 조건을 판단하는 동일한 작업을 수행한다. 하지만 메서드의 이름이 다르기 때문에 두 메서드의 내부 구현을 정확하게 이해하지 못한다면 두 메서드가 동일한 작업을 수행하는 것을 알기 어렵다
- 이 메서드는 클라이언트가 협력하는 객체의 종류를 알도록 강요한다. PeriodCondition을 사용하는 코드를 SequenceCondition을 사용하도록 변경하려면, 객체를 변경하는 것뿐만 아니라 호출하는 메서드도 변경해야 한다.


```java
// TO-BE
public class PeriodCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {}
}

public class SequenceCondition implements DiscountCondition {
    public boolean isSatisfiedBy(Screening screening) {}
}
```


# 명령 - 쿼리 분리 원칙

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

위처럼 명령과 쿼리를 분류하면, 객체의 사이드 이펙트를 제어하기가 수월해진다. <br>
쿼리는 객체의 상태를 변경하지 않기 때문에 반복적으로 호출하더라도 상관없다. <br>
명령이 개입하지 않는 한 쿼리의 값은 변경되지 않기 때문에 결과를 예측하기 쉬워진다.












