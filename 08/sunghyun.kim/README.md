# 의존성 이해하기

### 변경과 의존성

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때, 두 객체 사이에 의존성이 존재하게 된다. <br>
의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.

- 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
- 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.


### 의존성 전이

<img width="842" alt="스크린샷 2024-04-04 오후 10 40 45" src="https://github.com/A-Little-Bit-Tech-Frontiers/The-Book-Object/assets/87420630/42cd86ca-b504-4871-ac43-84bd3cff4756">

의존성은 전이될 수 있다. <br>
의존성은 함께 변경될 수 있는 가능성을 의미하기 때문에, 모든 경우에 의존성이 전이되는 것은 아니다.

### 컨텍스트 독립성

클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다. <br>
구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.

클래스가 특정한 문맥에 강하게 결합될수록, 다른 문맥에서 사용하기는 더 어려워진다. <br>
클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면, 다른 문맥에서 재사용하기가 더 수월해진다. <br>
컨텍스트에 대한 정보가 적으면 적을수록 더 다양한 컨텍스트에서 재사용될 수 있다.

<br>
<hr>

# 유연한 설계

### 의존성과 결합도

바람직한 의존성은 **재사용성**과 관련이 있다. <br>
어떤 의존성이 다양한 환경에서 클래스를 재사용할 수 없다면, 그 의존성은 바람직하지 못한 것이다. <br>
의존성이 재사용을 방해한다면 결합도가 강하고, 재사용을 쉽게 허용한다면 결합도가 느슨하다.

### new는 해롭다

- new 연산자를 사용하기 위해서는 구체 클래스의 이름을 기술해야 한다. 따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수 밖에 없기 때문에 결합도가 높아진다.
- new 연산자는 생성하려는 구체 클래스뿐만 아니라 어떤 인자를 사용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.









