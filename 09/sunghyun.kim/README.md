# 개방 폐쇄 원칙

- 확장에 열려 있다: 요구사항이 변경될 때 이 변경에 맞게 새로운 동작을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀 있다: 기존의 코드를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

### 추상화

개방 폐쇄 원칙의 핵심은 **추상화에 의존하는 것**이다. <br>
추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고, 문맥에 따라 변하는 부분은 생략된다.

<br>
<hr>

# 생성 사용 분리

결합도가 높아질수록 개방 폐쇄 원칙을 따르는 구조를 설계하기가 어려워진다. <br>
알아야 하는 지식이 많으면 결합도도 높아진다. 특히 객체 생성에 대한 지식은 과도한 결합도를 초래한다.

<img width="762" alt="스크린샷 2024-04-11 오후 9 10 43" src="https://github.com/A-Little-Bit-Tech-Frontiers/The-Book-Object/assets/87420630/cf55d3cd-1f5a-4219-bfec-d4ee0371febe">

> factory를 사용하면 Movie와 AmountDiscountPolicy를 생성하는 책임 모두를 factory로 이동할 수 있다. <br>
> client는 오직 사용과 관련된 책임만 지고 생성과 관련된 어떤 지식도 가지지 않을 수 있다.

<br>
<hr>

# 의존성 역전 원칙

### 추상화와 의존성 역전

객체 사이의 협력이 존재할 때, 그 협력의 본질을 답고 있는 것은 상위 수준의 정책이다. <br>
Movie와 AmountDiscountPolicy 사이의 협력이 가지는 본질은 영화의 가격을 계산하는 것이다. <br>
어떻게 할인 금액을 계산할 것인지는 협력의 본질이 아니다. 

이런 상위 수준의 클래스가 하위 수준의 클래스에 의존한다면, 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 될 것이다. <br>
이 경우에 해결법은 **추상화**이다. Movie와 AmountDiscountPolicy 모두 추상화에 의존하도록 수정하면 하위 수준 클래스의 변경으로 인해, 상위 수준의 클래스가 영향을 받는 것을 방지할 수 있다.


<br>
<hr>

# 유연성

### 유연한 설계는 유연성이 필요할 때만 옳다

유연한 설계라는 말의 이면에는 복잡한 설계라는 의미가 숨어 있다. <br>
변경은 예상이 아니라 현실이어야 한다. 미래에 변경이 일어날지도 모른다는 막연한 불안감은 불필요하게 복잡한 설계를 낳는다. <br>
아직 일어나지 않은 변경은 변경이 아니다.

설계가 유연할수록 클래스 구조와 객체 구조 사이의 거리는 점점 멀어진다. <br>
따라서 유연함은 단순성과 명확성의 희생 위에서 자라난다. <br>
유연한 설계를 단순하고 명확하게 만드는 유일한 방법은 사람들 간의 긴밀한 커뮤니케이션 뿐이다.

















